* 数据类型
	* 基本(值)类型: Number/String/Boolean/Null/Undefined
	* 引用(对象)类型 : array/function/object
	* 判断类型: typeof/instanceof/null
* 对象
	* 多个数据(属性)的集合
	* 属性组成:
		* 属性名 : 字符串(标识)
		* 属性值 : 任意类型
	* 属性的分类:
		* 一般 : 属性值不是function  描述对象的状态
		* 方法 : 属性值为function的属性  描述对象的行为
	* 特别的对象
		* 数组
		* 函数
	* 如何操作内部属性(方法)
		* obj.xxx
		* obj['xxx']
* 函数
	* 多条可执行语句的封装体---->函数是一个可执行的东西
	* 函数也是对象
		* 从语法上判断 : instanceof
		* 可以通过.操作内部属性/方法: fn.prototype/fn.call()/apply()
	* 函数的3种不同角色
		* 一般函数 : 直接调用
		* 构造函数 : 通过new调用
		* 对象 : 通过.调用内部的属性/方法
	* 函数中的this
		* 显式指定谁: obj.xxx()
		* 通过call/apply指定谁调用: xxx.call(obj)
		* 不指定谁调用: xxx()  : window
		* 回调函数: 看背后是通过谁来调用的: window/其它
	* 函数自调用:
		(function(window, obj){
			//函数体
		})(window, obj)
* 原型与原型链
	* 所有函数都会有两个特别的属性:
		* prototype : 显式原型   --->作为函数
		* __proto__ : 隐式原型   --->作为实例对象
	* 所有实例对象都有一个特别的属性:
		* __proto__ : 隐式原型
	* 显式原型与隐式原型的关系
		* 函数的prototype: 定义函数时被自动赋值, 值为{}
		* 实例对象的__proto__: 通过new调用构造函数创建对象时被自动赋值, 值为构造函数的prototype值
		* 实例对象的__proto__是对应的构造函数的prototype值, 它们都指向了同一个空object对象, 即为原型对象(父对象)
	* 原型链
		* 所有的实例对象都有__proto__属性, 原型对象是一个实例对象
		* 这样通过__proto__属性就形成了一个链的结构---->原型链
		* 当我们通过对象查找对象内部的属性/方法时, 会沿着这个原型链查找
		* 赋值时不会使用原型链, 而只是在当前对象中进行操作
		* obj.tt.test = function(); //先查找tt, 找到后再赋值

* 执行上下文环境对象和执行上下文环境栈
	* 上下文: 由js引擎自动创建的对象, 包含对应作用域中的变量属性
	* 变量提升: 在变量定义语句之前, 就可以访问到这个变量
	* 分类:
		* 全局 : window
		* 函数
	* 生命周期
		* 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡
		* 函数 : 调用函数时产生, 函数执行完时死亡
	* 包含哪些属性:
		* 全局 : 
			* 用var定义的全局变量  ==>undefined
			* 使用function声明的函数   ===>function
			* this   ===>window
		* 函数
			* 用var定义的局部变量  ==>undefined
			* 使用function声明的函数   ===>function
			* this   ===> 调用函数的对象, 如果没有指定就是window 
			* 形参变量   ===>对应实参值
			* arguments ===>实参列表的伪数组
	* 上下文对象创建和初始化的过程
		* 全局:
			* 在全局代码执行前最先创建一个全局上下文对象(window)
			* 收集一些全局变量, 并初始化
			* 将这些变量设置为上下文对象的属性
		* 函数:
			* 在调用函数时, 在执行函数体之前先创建一个函数上下文对象
			* 收集一些局部变量, 并初始化
			* 将这些变量设置为上下文对象的属性
* 作用域与作用域链
	* 是什么? : 一块代码区域
	* 分类:
		* 全局
		* 函数
		* js没有块作用域(在ES6之前)
	* 什么时候产生?
		* 全局 : 只要指定好<script>就确定了
		* 函数 : 定义好函数
	* 作用?
		* 隔离变量, 可以在不同作用域定义同名的变量不冲突
	* 区别作用域与上下文
		* 作用域
			* 静态的 : 编码时就确定了(不是在运行时), 一旦确定就不会变化了
		* 上下文
			* 动态的 : 执行代码时动态创建(对象), 当执行结束消失
			* 上下文是在对应的函数作用域中
	* 作用域链:
		* 多个嵌套的作用域形成的链, 链的方向的由内向外(链头当前作用域, 链尾是全局作用域)
		* 当我们在查找变量时, 沿着作用链由由内向外查找
* 闭包 
	* 理解:
		* 当嵌套的内部函数引用了外部函数的变量时就产生了闭包
		* 通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用变量属性
	* 作用:
		* 延长局部变量的生命周期
		* 让函数外部能操作内部的局部变量
	* 写一个闭包程序
		function fn1() {
			var a = 2;
			function fn2() {
				a++;
				console.log(a);
			}
			return fn2;
		}
		var f = fn1();
		f();
		f();
	* 闭包应用:
		* 回调函数
		* 模块化
		* 循环遍历加监听
		* jQuery
	* 缺点:
		* 变量占用内存的时间可能会过长, 可能导致内存泄露
		* 解决:
			* 及时释放 : f = null;